# -*- coding: utf-8 -*-
"""Geofencing_against_Outliers

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17W8ypIF9tpRy0EUR-NrmXaYW9lUKsHiZ
"""

# Step 1: Importing relevant libraries
import numpy as np
import random as rd
import matplotlib.pyplot as plt
import seaborn as sns
import scipy as spy
import timeit

# Step 2: Generating random points : Dataset
rd.seed(9) # set to generate similar data points on every execution
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
empty_list=[]
for i in coordinates:
    for j in i:
       empty_list.append(j)


sns.scatterplot(latitude, longitude)

# Step 3
# Method 1: Distance-based measures for outlier detection in the dataset
# Execution Time, Time-Complexity Graphs 

# Minkowski Distance
setup_code = """  
import numpy as np
import random as rd
import scipy as spy
rd.seed(9)
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
cord_list= np.array(coordinates_list)  """


statement_minkowski = """
minkowski_dist=[]
i=0
while i < (len(cord_list) - 1):
      #print(spy.spatial.distance.minkowski(cord_list[i], cord_list[i+1]) )
      for j in range(0,i):
          minkowski_dist.append(spy.spatial.distance.minkowski(cord_list[j], cord_list[j+1]))
      i+=1"""

print(f" Minkowski execution time is: {timeit.timeit(setup = setup_code, stmt = statement_minkowski, number = 100)}")

ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement_minkowski, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Minkowski Distance')

# Euclidean Distance
setup_code = """  
import numpy as np
import random as rd
import scipy as spy
rd.seed(9)
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
cord_list= np.array(coordinates_list)  """


statement_euclidean = """
euclidean_dist=[]
i=0
while i < (len(cord_list)-1):
    
    for j in range(0,i):
        euclidean_dist.append(spy.spatial.distance.euclidean(cord_list[j], cord_list[j+1]))
    i+=1
      """

print(f" Euclidean execution time is: {timeit.timeit(setup = setup_code, stmt = statement_euclidean, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement_euclidean, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Euclidean Distance')

# Cosine Distance
setup_code = """  
import numpy as np
import random as rd
import scipy as spy
rd.seed(9)
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
cord_list= np.array(coordinates_list)  """


statement_Cosine = """
Cosine_dist=[]
i=0
while i < (len(cord_list)-1):
    
    for j in range(0,i):
        Cosine_dist.append(spy.spatial.distance.cosine(cord_list[j], cord_list[j+1]))
    i+=1
      """
print(f" Cosine execution time is: {timeit.timeit(setup = setup_code, stmt = statement_Cosine, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement_Cosine, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Cosine Distance')

# Cityblock (Manhattan) Distance
setup_code = """  
import numpy as np
import random as rd
import scipy as spy
rd.seed(9)
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
cord_list= np.array(coordinates_list)  """


statement_cityblock = """
cityblock_dist=[]
i=0
while i < (len(cord_list)-1):
    
    for j in range(0,i):
        cityblock_dist.append(spy.spatial.distance.cityblock(cord_list[j], cord_list[j+1]))
    i+=1
      """
print(f" Cityblock(Manhattan) execution time is: {timeit.timeit(setup = setup_code, stmt = statement_cityblock, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement_cityblock, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Cityblock(Manhattan) Distance')

# Chebyshev Distance
setup_code = """  
import numpy as np
import random as rd
import scipy as spy
rd.seed(9)
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
cord_list= np.array(coordinates_list)  """


statement_chebyshev = """
chebyshev_dist=[]
i=0
while i < (len(cord_list)-1):
    
    for j in range(0,i):
        chebyshev_dist.append(spy.spatial.distance.chebyshev(cord_list[j], cord_list[j+1]))
    i+=1
      """
print(f" Chebyshev execution time is: {timeit.timeit(setup = setup_code, stmt = statement_chebyshev, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement_chebyshev, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Chebyshev Distance')

# Canberra Distance
setup_code = """  
import numpy as np
import random as rd
import scipy as spy
rd.seed(9)
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
cord_list= np.array(coordinates_list)  """


statement_canberra = """
canberra_dist=[]
i=0
while i < (len(cord_list)-1):
    
    for j in range(0,i):
        canberra_dist.append(spy.spatial.distance.canberra(cord_list[j], cord_list[j+1]))
    i+=1
      """
print(f" Canberra execution time is: {timeit.timeit(setup = setup_code, stmt = statement_canberra, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement_canberra, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Canberra Distance')

# Braycurtis Distance
setup_code = """  
import numpy as np
import random as rd
import scipy as spy
rd.seed(9)
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
cord_list= np.array(coordinates_list)  """


statement_braycurtis = """
braycurtis_dist=[]
i=0
while i < (len(cord_list)-1):
    
    for j in range(0,i):
        braycurtis_dist.append(spy.spatial.distance.braycurtis(cord_list[j], cord_list[j+1]))
    i+=1
      """
print(f" Braycurtis execution time is: {timeit.timeit(setup = setup_code, stmt = statement_braycurtis, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement_braycurtis, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Braycurtis Distance')

# Pearson Correlation Distance
setup_code = """  
import numpy as np
import random as rd
import scipy as spy
rd.seed(9)
latitude = []
longitude= []
for num in range(1,100):
    latitude.append(rd.randint(0,90))
    longitude.append(rd.randint(0,90))      
      
coordinates=tuple(zip(latitude,longitude)) 
#print(coordinates)
coordinates_list=list(zip(latitude, longitude))
cord_list= np.array(coordinates_list)  """


statement_Pearson = """
Pearson_dist=[]
i=0
while i < (len(cord_list)-1):
    
    for j in range(0,i):
        Pearson_dist.append(spy.spatial.distance.correlation(cord_list[j], cord_list[j+1]))
    i+=1
      """
print(f"  Pearson Correlation execution time is: {timeit.timeit(setup = setup_code, stmt = statement_Pearson, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement_Pearson, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title(' Pearson Correlation Distance')

# Method 2: Geofencing Algorithms


# Algorithm 1 : Ray Casting Algorithm 

# For 3-sided Polygon, calculating execution time and plotting time complexity graph

setup_code = """  
# Ray casting algorithm

from collections import namedtuple
from pprint import pprint as pp
import sys
"""

statement = """ 
from collections import namedtuple
from pprint import pprint as pp
import sys
 
Pt = namedtuple('Pt', 'x, y')               # Point
Edge = namedtuple('Edge', 'a, b')           # Polygon edge from a to b
Poly = namedtuple('Poly', 'name, edges')    # Polygon
 
_eps = 0.00001
_huge = sys.float_info.max
_tiny = sys.float_info.min
 
def rayintersectseg(p, edge):
    ''' takes a point p=Pt() and an edge of two endpoints a,b=Pt() of a line segment returns boolean
    '''
    a,b = edge
    if a.y > b.y:
        a,b = b,a
    if p.y == a.y or p.y == b.y:
        p = Pt(p.x, p.y + _eps)
 
    intersect = False
 
    if (p.y > b.y or p.y < a.y) or (
        p.x > max(a.x, b.x)):
        return False
 
    if p.x < min(a.x, b.x):
        intersect = True
    else:
        if abs(a.x - b.x) > _tiny:
            m_red = (b.y - a.y) / float(b.x - a.x)
        else:
            m_red = _huge
        if abs(a.x - p.x) > _tiny:
            m_blue = (p.y - a.y) / float(p.x - a.x)
        else:
            m_blue = _huge
        intersect = m_blue >= m_red
    return intersect
 
def _odd(x): return x%2 == 1
 
def ispointinside(p, poly):
    ln = len(poly)
    return _odd(sum(rayintersectseg(p, edge)
                    for edge in poly.edges ))
 
if __name__ == '__main__':
    polys = [
      Poly(name='Three-sided Polygon', edges=(
        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),
        Edge(a=Pt(x=10, y=0), b=Pt(x=0, y=10)),
        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0))
        ))]
    testpoints = (Pt(x=8, y=7), Pt(x=8, y=7)) 
 
    print(" TESTING WHETHER POINTS ARE WITHIN POLYGONS")
    for poly in polys:
        #polypp(poly)
        print ('   ', '\t'.join("%s: %s" % (p, ispointinside(p, poly)) for p in testpoints[:]))
"""

print( f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Ray Casting Algorithm: 3-sided Polygon')

# Algorithm 1 : Ray Casting Algorithm 

# For 4-sided Polygon, calculating execution time and plotting time complexity graph

setup_code = """  
# Ray casting algorithm

from collections import namedtuple
from pprint import pprint as pp
import sys
"""

statement = """ 
from collections import namedtuple
from pprint import pprint as pp
import sys
 
Pt = namedtuple('Pt', 'x, y')               # Point
Edge = namedtuple('Edge', 'a, b')           # Polygon edge from a to b
Poly = namedtuple('Poly', 'name, edges')    # Polygon
 
_eps = 0.00001
_huge = sys.float_info.max
_tiny = sys.float_info.min
 
def rayintersectseg(p, edge):
    ''' takes a point p=Pt() and an edge of two endpoints a,b=Pt() of a line segment returns boolean
    '''
    a,b = edge
    if a.y > b.y:
        a,b = b,a
    if p.y == a.y or p.y == b.y:
        p = Pt(p.x, p.y + _eps)
 
    intersect = False
 
    if (p.y > b.y or p.y < a.y) or (
        p.x > max(a.x, b.x)):
        return False
 
    if p.x < min(a.x, b.x):
        intersect = True
    else:
        if abs(a.x - b.x) > _tiny:
            m_red = (b.y - a.y) / float(b.x - a.x)
        else:
            m_red = _huge
        if abs(a.x - p.x) > _tiny:
            m_blue = (p.y - a.y) / float(p.x - a.x)
        else:
            m_blue = _huge
        intersect = m_blue >= m_red
    return intersect
 
def _odd(x): return x%2 == 1
 
def ispointinside(p, poly):
    ln = len(poly)
    return _odd(sum(rayintersectseg(p, edge)
                    for edge in poly.edges ))
 
if __name__ == '__main__':
    polys = [
      Poly(name='4-sided Polygon', edges=(
        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),
        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),
        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),
        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0))
        ))]
    testpoints = (Pt(x=8, y=7), Pt(x=8, y=7)) 
 
    print(" TESTING WHETHER POINTS ARE WITHIN POLYGONS")
    for poly in polys:
        #polypp(poly)
        print ('   ', '\t'.join("%s: %s" % (p, ispointinside(p, poly)) for p in testpoints[:]))
"""

print( f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Ray Casting Algorithm: 4-sided Polygon')

# Algorithm 1 : Ray Casting Algorithm 

# For 5-sided Polygon, calculating execution time and plotting time complexity graph
setup_code = """  
# Ray casting algorithm

from collections import namedtuple
from pprint import pprint as pp
import sys
"""

statement = """ 
from collections import namedtuple
from pprint import pprint as pp
import sys
 
Pt = namedtuple('Pt', 'x, y')               # Point
Edge = namedtuple('Edge', 'a, b')           # Polygon edge from a to b
Poly = namedtuple('Poly', 'name, edges')    # Polygon
 
_eps = 0.00001
_huge = sys.float_info.max
_tiny = sys.float_info.min
 
def rayintersectseg(p, edge):
    ''' takes a point p=Pt() and an edge of two endpoints a,b=Pt() of a line segment returns boolean
    '''
    a,b = edge
    if a.y > b.y:
        a,b = b,a
    if p.y == a.y or p.y == b.y:
        p = Pt(p.x, p.y + _eps)
 
    intersect = False
 
    if (p.y > b.y or p.y < a.y) or (
        p.x > max(a.x, b.x)):
        return False
 
    if p.x < min(a.x, b.x):
        intersect = True
    else:
        if abs(a.x - b.x) > _tiny:
            m_red = (b.y - a.y) / float(b.x - a.x)
        else:
            m_red = _huge
        if abs(a.x - p.x) > _tiny:
            m_blue = (p.y - a.y) / float(p.x - a.x)
        else:
            m_blue = _huge
        intersect = m_blue >= m_red
    return intersect
 
def _odd(x): return x%2 == 1
 
def ispointinside(p, poly):
    ln = len(poly)
    return _odd(sum(rayintersectseg(p, edge)
                    for edge in poly.edges ))
 
if __name__ == '__main__':
    polys = [
      Poly(name='Five-sided Polygon', edges=(
        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),
        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),
        Edge(a=Pt(x=10, y=10), b=Pt(x=5, y=15)),
        Edge(a=Pt(x=5, y=15), b=Pt(x=0, y=10)),
        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0)),
        ))]
    testpoints = (Pt(x=8, y=7), Pt(x=8, y=7)) 
 
    print(" TESTING WHETHER POINTS ARE WITHIN POLYGONS")
    for poly in polys:
        #polypp(poly)
        print ('   ', '\t'.join("%s: %s" % (p, ispointinside(p, poly)) for p in testpoints[:]))
"""

print( f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Ray Casting Algorithm: 5-sided Polygon')

# Algorithm 1 : Ray Casting Algorithm 

# For 4-sided Polygon with a hole, calculating execution time and plotting time complexity graph

setup_code = """  
# Ray casting algorithm

from collections import namedtuple
from pprint import pprint as pp
import sys
"""

statement = """ 
from collections import namedtuple
from pprint import pprint as pp
import sys
 
Pt = namedtuple('Pt', 'x, y')               # Point
Edge = namedtuple('Edge', 'a, b')           # Polygon edge from a to b
Poly = namedtuple('Poly', 'name, edges')    # Polygon
 
_eps = 0.00001
_huge = sys.float_info.max
_tiny = sys.float_info.min
 
def rayintersectseg(p, edge):
    ''' takes a point p=Pt() and an edge of two endpoints a,b=Pt() of a line segment returns boolean
    '''
    a,b = edge
    if a.y > b.y:
        a,b = b,a
    if p.y == a.y or p.y == b.y:
        p = Pt(p.x, p.y + _eps)
 
    intersect = False
 
    if (p.y > b.y or p.y < a.y) or (
        p.x > max(a.x, b.x)):
        return False
 
    if p.x < min(a.x, b.x):
        intersect = True
    else:
        if abs(a.x - b.x) > _tiny:
            m_red = (b.y - a.y) / float(b.x - a.x)
        else:
            m_red = _huge
        if abs(a.x - p.x) > _tiny:
            m_blue = (p.y - a.y) / float(p.x - a.x)
        else:
            m_blue = _huge
        intersect = m_blue >= m_red
    return intersect
 
def _odd(x): return x%2 == 1
 
def ispointinside(p, poly):
    ln = len(poly)
    return _odd(sum(rayintersectseg(p, edge)
                    for edge in poly.edges ))
 
if __name__ == '__main__':
    polys = [
      Poly(name='square_hole', edges=(
        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),
        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),
        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),
        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0)),
        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=7.5, y=2.5)),
        Edge(a=Pt(x=7.5, y=2.5), b=Pt(x=7.5, y=7.5)),
        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=2.5, y=7.5)),
        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=2.5, y=2.5))
        ))]
    testpoints = (Pt(x=8, y=7), Pt(x=8, y=7)) 
 
    print(" TESTING WHETHER POINTS ARE WITHIN POLYGONS")
    for poly in polys:
        #polypp(poly)
        print ('   ', '\t'.join("%s: %s" % (p, ispointinside(p, poly)) for p in testpoints[:]))
"""

print( f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Ray Casting Algorithm: 4-sided Polygon with a hole')

# Algorithm 1 : Ray Casting Algorithm 

# For 5-sided Polygon, calculating execution time and plotting time complexity graph
setup_code = """  
# Ray casting algorithm

from collections import namedtuple
from pprint import pprint as pp
import sys
"""

statement = """ 
from collections import namedtuple
from pprint import pprint as pp
import sys
 
Pt = namedtuple('Pt', 'x, y')               # Point
Edge = namedtuple('Edge', 'a, b')           # Polygon edge from a to b
Poly = namedtuple('Poly', 'name, edges')    # Polygon
 
_eps = 0.00001
_huge = sys.float_info.max
_tiny = sys.float_info.min
 
def rayintersectseg(p, edge):
    ''' takes a point p=Pt() and an edge of two endpoints a,b=Pt() of a line segment returns boolean
    '''
    a,b = edge
    if a.y > b.y:
        a,b = b,a
    if p.y == a.y or p.y == b.y:
        p = Pt(p.x, p.y + _eps)
 
    intersect = False
 
    if (p.y > b.y or p.y < a.y) or (
        p.x > max(a.x, b.x)):
        return False
 
    if p.x < min(a.x, b.x):
        intersect = True
    else:
        if abs(a.x - b.x) > _tiny:
            m_red = (b.y - a.y) / float(b.x - a.x)
        else:
            m_red = _huge
        if abs(a.x - p.x) > _tiny:
            m_blue = (p.y - a.y) / float(p.x - a.x)
        else:
            m_blue = _huge
        intersect = m_blue >= m_red
    return intersect
 
def _odd(x): return x%2 == 1
 
def ispointinside(p, poly):
    ln = len(poly)
    return _odd(sum(rayintersectseg(p, edge)
                    for edge in poly.edges ))
 
if __name__ == '__main__':
    polys = [
      Poly(name='Six-sided Polygon', edges=(
        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),
        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),
        Edge(a=Pt(x=10, y=10), b=Pt(x=5, y=15)),
        Edge(a=Pt(x=5, y=15), b=Pt(x=0, y=10)),
        Edge(a=Pt(x=10, y=10), b=Pt(x=5, y=15)),
        Edge(a=Pt(x=5, y=15), b=Pt(x=0, y=10)),
        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0)),
        ))]
    testpoints = (Pt(x=8, y=7), Pt(x=8, y=7)) 
 
    print(" TESTING WHETHER POINTS ARE WITHIN POLYGONS")
    for poly in polys:
        #polypp(poly)
        print ('   ', '\t'.join("%s: %s" % (p, ispointinside(p, poly)) for p in testpoints[:]))
"""

print( f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Ray Casting Algorithm: 6-sided Polygon')

# Algorithm 1 : Ray Casting Algorithm 

# For 6-sided Polygon, calculating execution time and plotting time complexity graph
setup_code = """  
# Ray casting algorithm

from collections import namedtuple
from pprint import pprint as pp
import sys
"""

statement = """ 
from collections import namedtuple
from pprint import pprint as pp
import sys
 
Pt = namedtuple('Pt', 'x, y')               # Point
Edge = namedtuple('Edge', 'a, b')           # Polygon edge from a to b
Poly = namedtuple('Poly', 'name, edges')    # Polygon
 
_eps = 0.00001
_huge = sys.float_info.max
_tiny = sys.float_info.min
 
def rayintersectseg(p, edge):
    ''' takes a point p=Pt() and an edge of two endpoints a,b=Pt() of a line segment returns boolean
    '''
    a,b = edge
    if a.y > b.y:
        a,b = b,a
    if p.y == a.y or p.y == b.y:
        p = Pt(p.x, p.y + _eps)
 
    intersect = False
 
    if (p.y > b.y or p.y < a.y) or (
        p.x > max(a.x, b.x)):
        return False
 
    if p.x < min(a.x, b.x):
        intersect = True
    else:
        if abs(a.x - b.x) > _tiny:
            m_red = (b.y - a.y) / float(b.x - a.x)
        else:
            m_red = _huge
        if abs(a.x - p.x) > _tiny:
            m_blue = (p.y - a.y) / float(p.x - a.x)
        else:
            m_blue = _huge
        intersect = m_blue >= m_red
    return intersect
 
def _odd(x): return x%2 == 1
 
def ispointinside(p, poly):
    ln = len(poly)
    return _odd(sum(rayintersectseg(p, edge)
                    for edge in poly.edges ))
 
if __name__ == '__main__':
    polys = [
      Poly(name='Six-sided Polygon', edges=(
        Edge(a=Pt(x=0, y=0), b=Pt(x=0, y=10)),
        Edge(a=Pt(x=0, y=10), b=Pt(x=5, y=15)),
        Edge(a=Pt(x=5, y=15), b=Pt(x=10, y=10)),
        Edge(a=Pt(x=10, y=10), b=Pt(x=10, y=0)),
        Edge(a=Pt(x=10, y=0), b=Pt(x=5, y=-15)),
        Edge(a=Pt(x=5, y=-15), b=Pt(x=0, y=0)),
        
        ))]
    testpoints = (Pt(x=8, y=7), Pt(x=8, y=7)) 
 
    print(" TESTING WHETHER POINTS ARE WITHIN POLYGONS")
    for poly in polys:
        #polypp(poly)
        print ('   ', '\t'.join("%s: %s" % (p, ispointinside(p, poly)) for p in testpoints[:]))
"""

print( f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100) for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title('Ray Casting Algorithm: 6-sided Polygon')

# Algorithm 2 : Winding Number Algorithm

# For 3-sided Polygon, calculating execution time and plotting time complexity graph

# is_left(): tests if a point is Left|On|Right of an infinite line.



setup_code = """  
  """

statement = """

def is_left(P0, P1, P2):
    return (P1[0] - P0[0]) * (P2[0][1] - P0[1]) - (P2[0][0] - P0[0]) * (P1[1] - P0[1])


#===================================================================

# wn_PnPoly(): winding number test for a point in a polygon
#     Input:  P = a point,
#             V[] = vertex points of a polygon
#     Return: wn = the winding number (=0 only if P is outside V[])

def wn_PnPoly(P, V):
    wn = 1   # the winding number counter

    # repeat the first vertex at end
    V = tuple(V[:]) + (V[0],)

    # loop through all edges of the polygon
    for i in range(len(V)-1):     # edge from V[i] to V[i+1]
        if V[i][1] < P[0][1]:        # start y <= P[1]
            if V[i+1][1] > P[0][1]:     # an upward crossing
                if is_left(V[i], V[i+1], P) > 0: # P left of edge
                    wn += 1           # have a valid up intersect
        else:                      # start y > P[1] (no test needed)
            if V[i+1][1] < P[0][1]:    # a downward crossing
                if is_left(V[i], V[i+1], P) < 0: # P right of edge
                    wn -= 1           # have a valid down intersect
    if wn > 0:
       return wn, 'outside'

    else:
       return wn, 'inside'
    return wn

V=[(0,0),(0,10),(10,0)]
P=[(8,7)]

#print(wn_PnPoly(P,V))
"""

print(f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100)
      for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title("Winding Number : 3-sided Polygon")

# Algorithm 2 : Winding Number Algorithm

# For 4-sided Polygon, calculating execution time and plotting time complexity graph

# is_left(): tests if a point is Left|On|Right of an infinite line.



setup_code = """  
  """

statement = """

def is_left(P0, P1, P2):
    return (P1[0] - P0[0]) * (P2[0][1] - P0[1]) - (P2[0][0] - P0[0]) * (P1[1] - P0[1])


#===================================================================

# wn_PnPoly(): winding number test for a point in a polygon
#     Input:  P = a point,
#             V[] = vertex points of a polygon
#     Return: wn = the winding number (=0 only if P is outside V[])

def wn_PnPoly(P, V):
    wn = 1   # the winding number counter

    # repeat the first vertex at end
    V = tuple(V[:]) + (V[0],)

    # loop through all edges of the polygon
    for i in range(len(V)-1):     # edge from V[i] to V[i+1]
        if V[i][1] < P[0][1]:        # start y <= P[1]
            if V[i+1][1] > P[0][1]:     # an upward crossing
                if is_left(V[i], V[i+1], P) > 0: # P left of edge
                    wn += 1           # have a valid up intersect
        else:                      # start y > P[1] (no test needed)
            if V[i+1][1] < P[0][1]:    # a downward crossing
                if is_left(V[i], V[i+1], P) < 0: # P right of edge
                    wn -= 1           # have a valid down intersect
    if wn > 0:
       return wn, 'outside'

    else:
       return wn, 'inside'
    return wn

V=[(0,0),(0,10),(10,10),(10,0)]
P=[(8,7)]

#print(wn_PnPoly(P,V))
"""

print(f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100)
      for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title("Winding Number : 4-sided Polygon")

# Algorithm 2 : Winding Number Algorithm

# For 4-sided Polygon, calculating execution time and plotting time complexity graph

# is_left(): tests if a point is Left|On|Right of an infinite line.



setup_code = """  
  """

statement = """

def is_left(P0, P1, P2):
    return (P1[0] - P0[0]) * (P2[0][1] - P0[1]) - (P2[0][0] - P0[0]) * (P1[1] - P0[1])


#===================================================================

# wn_PnPoly(): winding number test for a point in a polygon
#     Input:  P = a point,
#             V[] = vertex points of a polygon
#     Return: wn = the winding number (=0 only if P is outside V[])

def wn_PnPoly(P, V):
    wn = 1   # the winding number counter

    # repeat the first vertex at end
    V = tuple(V[:]) + (V[0],)

    # loop through all edges of the polygon
    for i in range(len(V)-1):     # edge from V[i] to V[i+1]
        if V[i][1] < P[0][1]:        # start y <= P[1]
            if V[i+1][1] > P[0][1]:     # an upward crossing
                if is_left(V[i], V[i+1], P) > 0: # P left of edge
                    wn += 1           # have a valid up intersect
        else:                      # start y > P[1] (no test needed)
            if V[i+1][1] < P[0][1]:    # a downward crossing
                if is_left(V[i], V[i+1], P) < 0: # P right of edge
                    wn -= 1           # have a valid down intersect
    if wn > 0:
       return wn, 'outside'

    else:
       return wn, 'inside'
    return wn

V=[(0,0),(0,10),(5,15),(10,10),(10,0)]
P=[(8,7)]

#print(wn_PnPoly(P,V))
"""

print(f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100)
      for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title("Winding Number : 5-sided Polygon")

# Algorithm 2 : Winding Number Algorithm

# For 6-sided Polygon, calculating execution time and plotting time complexity graph

# is_left(): tests if a point is Left|On|Right of an infinite line.



setup_code = """  
  """

statement = """

def is_left(P0, P1, P2):
    return (P1[0] - P0[0]) * (P2[0][1] - P0[1]) - (P2[0][0] - P0[0]) * (P1[1] - P0[1])


#===================================================================

# wn_PnPoly(): winding number test for a point in a polygon
#     Input:  P = a point,
#             V[] = vertex points of a polygon
#     Return: wn = the winding number (=0 only if P is outside V[])

def wn_PnPoly(P, V):
    wn = 1   # the winding number counter

    # repeat the first vertex at end
    V = tuple(V[:]) + (V[0],)

    # loop through all edges of the polygon
    for i in range(len(V)-1):     # edge from V[i] to V[i+1]
        if V[i][1] < P[0][1]:        # start y <= P[1]
            if V[i+1][1] > P[0][1]:     # an upward crossing
                if is_left(V[i], V[i+1], P) > 0: # P left of edge
                    wn += 1           # have a valid up intersect
        else:                      # start y > P[1] (no test needed)
            if V[i+1][1] < P[0][1]:    # a downward crossing
                if is_left(V[i], V[i+1], P) < 0: # P right of edge
                    wn -= 1           # have a valid down intersect
    if wn > 0:
       return wn, 'outside'

    else:
       return wn, 'inside'
    return wn

V=[(0,0),(0,10),(5,15),(10,10),(10,0),(5,-15)]
P=[(8,7)]

#print(wn_PnPoly(P,V))
"""

print(f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100)
      for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title("Winding Number : 6-sided Polygon")

# Algorithm 2 : Winding Number Algorithm

# For 4-sided Polygon, calculating execution time and plotting time complexity graph

# is_left(): tests if a point is Left|On|Right of an infinite line.



setup_code = """  
  """

statement = """

def is_left(P0, P1, P2):
    return (P1[0] - P0[0]) * (P2[0][1] - P0[1]) - (P2[0][0] - P0[0]) * (P1[1] - P0[1])


#===================================================================

# wn_PnPoly(): winding number test for a point in a polygon
#     Input:  P = a point,
#             V[] = vertex points of a polygon
#     Return: wn = the winding number (=0 only if P is outside V[])

def wn_PnPoly(P, V):
    wn = 1   # the winding number counter

    # repeat the first vertex at end
    V = tuple(V[:]) + (V[0],)

    # loop through all edges of the polygon
    for i in range(len(V)-1):     # edge from V[i] to V[i+1]
        if V[i][1] < P[0][1]:        # start y <= P[1]
            if V[i+1][1] > P[0][1]:     # an upward crossing
                if is_left(V[i], V[i+1], P) > 0: # P left of edge
                    wn += 1           # have a valid up intersect
        else:                      # start y > P[1] (no test needed)
            if V[i+1][1] < P[0][1]:    # a downward crossing
                if is_left(V[i], V[i+1], P) < 0: # P right of edge
                    wn -= 1           # have a valid down intersect
    if wn > 0:
       return wn, 'outside'

    else:
       return wn, 'inside'
    return wn

V=[(0,0),(0,10),(10,10),(10,0),(2.5,2.5),(7.5,2.5),(7.5,7.5),(2.5,7.5)]
P=[(8,7)]

#print(wn_PnPoly(P,V))
"""

print(f"Execution time is: {timeit.timeit(setup = setup_code, stmt = statement, number = 100)}")
ns = np.linspace(10, 10000, 100, dtype=int)
# red plots
ts = [timeit.timeit(setup = setup_code, stmt = statement, number = 100)
      for n in ns]
plt.plot(ns, ts, 'or')

degree = 4
coeffs = np.polyfit(ns, ts, degree)
p = np.poly1d(coeffs)
plt.plot(ns, ts,'or')
plt.plot(ns, [p(n) for n in ns],'-b')
plt.title("Winding Number : 4-sided Polygon with a hole")